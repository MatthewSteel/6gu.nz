The long list:
 - better keyboard nav,
 - better formula display/input,
 - complex data structures :-(
 - compiled functions and calls
 - storage
 - js interop,
 - collaboration,
 - dynamic sheet creation etc.
 - custom cell formatting incl charts.


OK, tech design for tables :-).
  - At first we can have n global "templates". All templates are global.
  - Extend parser to allow `func(param=expr, ...)`. Recursive?
  - When a formula is just `func(params)?` we put a `templateId` on it.
  - Templates have names, heh.

Hmm, there's some annoying stuff around default args, between-sheet references, functions and circular references. In v0 I'm going to have no recursion, function calls happen when they seem to happen, dots being dots, etc.


What do things look like from top-level?

Compile sheets to functions ahead of time and store them in an object. That's easy enough.
When we call a function, we say `{ ...valuesForSheet, ...args }` where `valuesForSheet` has been filled in.
What I'm most worried about is top-level stuff -- can we compile it and reuse it? Kinda -- if terms are removed, the tsort stays intact. If terms are inserted, the ordering need only change between the two points (and we can run things from that point on.) We can chunk the computation and it can be JITted just fine.

(When a node is added, we're lucky -- we can do with a linear scan and just put it "as late as possible" into the computation DAG.)

Sounds like a decent plan.

Steps:
  1. Compile functions (up-front),
  2. Put functions and calls into the graph,

Boy a lot of stuff is going to get rewritten when we need to make this fast...


Hmm, there's an annoying normalisation question -- all "far" references are global, but "near" references can be either local or global.

For the moment let's make all near references local. :-) :-(.

I think we need to write a proper parser now :-(((.


What do we know about the parser?
  - Top-level cross links are "different" somehow? "Global lookups"?

`=table.cell` is a special kind of reference.
`=table.cell.key` is kinda the same.
`=table.cell(k=v)` is too?
`=cell` as well, I think.

`=table(cell=v)` is different though, I think.
`=table` is different again?

What do we want?
{ call: $ref, args: [...] } I guess.
or
{ lookup: key, ref: $expr }

And references look like,

{ ref: $cell, tableRef: $table? }
or


{ lookup: { lookup: { ref: $tableId }, key: $cellId }, key: $key }
{ call: { ref: $tableId }, args: [] }
{ call: { lookup: { ref: $tableId }, key: $cellId }, args: [] }

So anything that's `=table` depends on the table, anything that's =table.cell depends on the cell, and

`table.cell` is special -- normally `=a.b.c` depends on `a`, but if `a` is a table we depend on `b` instead.
  Is that right?

Oh, for the moment local links always have to be local. That's important. So really references are just cells?

  replace { lookup: { ref: $tableId }, key: $cellId } with { ref: $cellId }.

OK, I think that works.

Then how do we evaluate this nonsense? Make a big damn expression? With helper functions on the outside? Build a function ourselves?

Say we have an expression like `cell1=table1(c2 = table2.c3 + c4)
  {
    name: 'cell1',
    formula: [{
      call: { ref: table1 },
      args: [
        { assign: c2, expr: [{ ref: c3 }, { op: '+' }, { ref: c4 }] },
      ],
    }],
  }
First things first: references.
 - table1, c3, c4. Do a tree-search recursively through the structure, through assign.exprs and call.args looking for refs.

Do we build a function for every cell? Seems a bit much...

We can get the template from further up if we want it.

Still not over the moon about errors... Kinda just want to try/catch at the top level.
  `iferror([table(foo=bar).cell], 0)`
That's pretty bad for collaboration, though -- don't want to take down the whole document because someone messes up. Fine, just check for errors.

  Except in functions, maybe?
    Local refs are "fast", global refs are "slow"?
    Naw, just make them all slow for now.

Translate `{ ref: table }` into
  { value: { ... }, function: f, template: table }
maybe?


OK, value is not just {k: v}, it's {k: {value: v}} etc. Got it.

What else?

Maybe we can pass an error into a function? I think we have to for `iferror`.

What about passing table references around? I think a table is an object that has { value: { data: {k: {v: v}}, template: t } }

(and that's the return value of a function call)

We build that thing for each one as we go.



function(data, globals, f) {
  try {
    data['cellId0'] = data['cellId0'] || { value: ${expand(expr)} };
  } catch(e) {
    data['cellId0'] = { error: e.toString() };
  }
  // ..

  return { data, template: 'literal', f };
}

What does ${expr} look like? Just what we have now?



When we "scan" a cell, we add its value to globals, and we

Oh shit, we have a problem with dynamic names.
  How bad is it?
  I think we actually literally want to store names in formulas :-(.
    - How do renames work? They don't :(.
    - OK, then we use names for function calls and stored objects, and we use ids at the top level. I think we can live with that.
  - We can "smarten up" the function calls later if we want.


Still not great about the errors -- we're catching them too high. Oh well.
  We probably want to just do what Excel etc do, but for now let's not have any errors, just blank values :-)


Sub-table stuff:
 - Internal scrolling?
 - Display of complex data types:
  - Arrays,
  - Objects,
  - "Tables".

Compilation

Collaboration...

Cell formatting


I think I've had a change of heart. Let's do this properly:
 - Every page is a function,
 - Every cell is returned by id (or name?)
 - We call the function once and wire up the contents.

What about interop?
 - Later. "Compat import/export" etc.
What about ever collecting garbage?
 - Later. "Mark variables as in/out."
What about closures?
 - They're fine.



What's next after that? Ideas:
 - A proper formula box,
 - Better formula parsing,
 - Thinking about the data model a bit more.
   - "template" property alongside value/error?
 - Thinking about laziness and/or conditional evaluation.
    - Possibly only evaluate functions when we use the `.` operator.
      - That way we can pass functions around without evaluating them.
      - Oh, is that _real_ laziness? It nests, after all...
      - We _do_ want the global sheets to evaluate, though.
        Let's not do "real" laziness. It won't translate into JS anyway.
        "Fake" laziness ("`.` means call") is compatible with real JS kinda.
        Definitely memoize though.
      Is it good enough for conditional execution and side-effects? Maybe not.
      It's confusing. How would we write `fib`?
      Too confusing.
      Make a special form. Either:
       - a `cond` cell format, or
       - a "delay" syntax. I like `[]` because it looks like a cell :-)
        - `[1].value`, or `(){ }`. lazy() is ok too...
          `if(n < 2, 1, lazy(fib(n-1) + fib(n-2)))` if it can work.
          might need to say `if(.., {value: 1}, lazy(...)).value` though :-(
          Then I like `if(.., [1], [...]).value`.
          What about actual arrays, then? We could use $[] I guess... or #[]
          Hmm, I kinda like that for an anonymous function :-).
          It could literally make an anonymous function? "Click on the #"

Great, I guess that works. (Productive...)
