Short-term TODO list:
 - Split up the reducer code,
 - Cell-size stuff :-/.
  - Cells are reasonably consistently sized, go all the way to the edges.
  - Probably have to do some pixel-density stuff?
    - css "resolution" or JS devicePixelRatio?

 - Rename, delete sheets and documents,
   - Click on "path elements" to pop,
   - Click on "last path element" to rename (if sheet/doc),
 - Load documents,
   - Drop-down for opening other files and deletion. Maybe copy?
 - Load from URL,
 - Url reflects location,
 - [index] on objects,
 - deploy it to some real server,
 - Google + Facebook login.
 - Favicon,
 - Page title text,
 - Don't try to save things that aren't ours (or if we're logged in)
 - Handle localStorage being full,
 - Clear localStorage before putting the thing in it, just in case.
 - Check unsaved docs that aren't in "the list" have never been saved.
 - document ids are "nicer",
 - Handle "unexpected logouts"?
 - `if` function (not lazy), iferror(?), stdev(?)
 - `atan2(0.5, in: ["degrees", "radians", "degrees"])`
 - first, last, reverse, slice, group, max, "not-deep order"/comparison
 - intro video/website/docs
 - browse into more things -- arrays etc, complex table elements.
 - cut down the number of renders.
 - Overridden deep values look special? Hrm... "parent overridden" prop?
 - Arr "looks like a table" if _every_ element is an obj or error?
   - work out `keys` at display time still?
 - Always display "special arrays" as arrays. Ditto special objects.
   - They should not look like tables for now.
Something something "unexpected logouts" too?

That's a lot...



The longer-term list:
 - V2 cut, copy, paste,
 - V2 Multi-select,
 - V2 "native" map/for etc?
 - V2 better formula box:
     - terms look like cells,
     - "click to write",
     - tab completion
 - V3 "actions" (xhr etc),
     - mutation story (redux?),
     - conditional evaluation, HOF or first-class cell references,
 - V3 js interop, in (npm) and out (export to js)
 - V4 collaboration,
 - ?? custom cell formatting incl charts-in-cells (user react components).
     - input modes for rich text?
 - ?? closures and first-class functions.
 - ?? laziness
 - ?? a website, some vids.
 - ?? putting it online
 - Totally offline: docs, scripts, _everything_ in storage/indexeddb.



Out of scope for MVP:
 - Browse into table/sheet cells (not "browse into anything complicated")
 - each
 - Concatenating tables/arrays, zip functions,
 - Date, time, random functions.
 - Range selection :-(
 - Cut copy paste :-((,
 - Undo/redo,
 - Better formula input (clicking),
 - Type tagging,
 - Maybe relative table/array references in formulas (?). `$row - 1`?
 - Animations, "Fly-in-from-side"
 - Value writes -- `cellObject(k1.k2.k3: v)`?
   - k1 lookup order "local sheet-element names, sheet names, cellObj prop"
   - cellArray(0: v) ? OK.


Next up:
 - Browse into array values,
   - Path at the top,
   - Storing the path in the view somehow.
     - Path is a lookupExpression from the selected sheet, I think.
       Except we have to invert it, and add more crap for unreified shit.
       Fine: `[{ name: 'fred' }, { index: 0 }]` haha
         Except we have to get the array name in there too...
           Each path element is a list?
             [[{ id: sldkfj }], [{ id: vnkfljg }, { index: 10 }], ...]?
       Can/should we get rid of byId? Meh, if it's there...
         `{ id: 'sldkfjsjf' }` too, then.
   - Should this be in redux? Probably...
     - It's a bit of a pain that "path validity" depends on cell values.
     - We can make the "effective view" a selector, I guess?
       - Righto. But later.


What do we think about multiple indexes to dig?
  arr[range(n), 0] could get the first column of a matrix.
Dunno... Doesn't seem powerful enough? I don't think it can transpose...


Philosophical differences:
  - Should tables contain formulas?
    - No: It makes overriding awkward -- those formulas can disappear.
    - Yes: "Augmenting" tables with "column formulas" is awkward.
  - Maybe a table can have a "column formula" that is internal to it, and
    when you override it you _can't_ override that formula...
      What does that even mean...
        I like it, though...


Possible projects after/during MVP work:
 - Undo/redo,
 - Cut, copy, paste,
 - Clicking on cells while editing formulas.
 - Drag select to make arrays/objects/tables? In a formula?
   - shift/ctrl + click could also make an array, or add to one :-)
   - Maybe "drag to select, makes an array. Hit 'tab' to turn it into an object/table". Seems reasonable?
   - "Make it an array" in the formula, or in the sheet, though?
 - Consistent cell-sizing and text-overflow?
 - Row/column headers (or scroll indicators of some other kind.)
    - Simple fake scroll bars, maybe?
    - Just shadows?
 - keyboard scrolling -- [shift or ctrl]+down scrolls current viewport?
 - Better sheet select, scratch-space,
 - Rethought book layout, maybe pop-over preview.


Different views of data. Hmm. If it's small you can "browse to it", if it's big you can see it?
  - "Expanded view" for arrays and "template-less" objects.
  - Just the array/object in the top-left corner, with biggish dimensions?
    Great!


An additional way to write lists/objects/tables:
  a[0] = 1
  a.b = 2
  a.b[1] = 3
  a[1].b = 3

One more: "Turn the previous cell into an array, and append to it:
  ,= 1
  .name = "Fred"

Helpful if we can edit whole-list/obj/table formulas too, so converting an array into a table is as easy as editing the formula.
  Hopefully we can truncate the unparsed value before it gets too long :-)
  ("If it has `...` in it, get rid of it :-)
    Or some "truncated" policy.


---------------
[obj][ a ][ b ]
[ 0 ][val][val]
---------------
[ 1 ][...][...]
[ 2 ][...][...]
---------------


I think we can let the user come up with primary keys. Names could be helpful, though...
  - Maybe maps/filters etc can have names in them?
  - References can be mapped onto the table, not global.
  - `While` tables can just have numbers, or not be named?

Also: we may want to support polymorphic arr["property"] and arr[i].

Can we select cols like `friends[[age, name]]` to get partial structs (or partial transpose-structs)?
  Maybe `friends[{age, name}]`? What is `{age, name}` though...
    They are "children by name, in the relative namespace of `friends`".
    That's nice.

    Should we merge lookup and lookupIndex? (Well, we have to display them differently...)
      We could call `.name` and `.index` something like `.key` instead?


Start shitty and upgrade it - for us and the user.
That means:
  - Let them import CSVs and "get to work" on them. Lookups, aggregates.
  - Let them "tidy" the data model up. Define cross-relationships for simpler formulas.
    - No, actually, I don't like this. How do you script some GTFS processing like this? Too much manual work. We don't want to be a fancy Excel, remember? AirTable have this problem too...
    - Maybe it's actually just a property of the table, then?
      Or maybe the user can script a transform from CSV -> "nice" table?
      Sure, that's doable.


Now, things about "dragging a cell down" etc... Auto-fills and so on. Are they just "fancy value input", or do they create formulas?


OK, I like the idea of making relational tables out of flat input.
  Should it just be a property of the table? "Do one-many on this col?"
  Dunno.
  Can we punt on this? How necessary is it to get this right right now?

Hmm, maybe we should have two kinds of tables -- value tables and "view" tables. Then computed columns are kinda "easy". Not too usable, though...

Do we face problems with recursion? Two-way data?
  Say we want to have a `.friends` relation.
    `a.friends.age` gives a list of ages.
    `a.friends.friends` is a circular reference problem, maybe?
      Actually, probably not. We can probably `flatten(a.friends.friends)`.
      _We_ need to come after friends, and _we_ need to come after friends?
      Yes. We can do a transitive closure! Hooray!

You can augment tables, to whatever you want with them, operate on them like values, _but_, we give good, useful ways to do "better" data transformations, and let the user build tools for their own use.

That's a good mission statement -- let the user do what they want to do, but give them headroom. Don't presume that we know best. We need to not only provide the best way of doing something but the _easiest_ as well.

Selection: In formulas it can make a list (of names), in the sheet it can make an object or array. Or do some formatting, or delete things.

I wonder -- what do users use "paste values" for?

Ugh, I suspect "data tables" will be dense with formulas, unless we can impose some structure.
  - "Value columns and formula columns" maybe?
  - "adjacent tables/arays of the same height scroll together"?

Maybe adding and removing columns copies the table?

Maybe we have "series" tables and "data" tables.

Hmm, tables are used for a bunch of different purposes :-/

It _would_ be nice if we could encourage users to "do reasonable things".
It would also be nice if we could support whatever workflows they are used to.

Series data often has rolling sums, time-averages etc.

Maybe there's "core" data and "augmenting" data? |||==ish.
  Niice.

Maybe that can be done automatically, though.
A table could have a "core" data-like content with surrounding computed cols/rows.

A few things:
 - We want it to work _as_ a database,
 - We want it to work _on_ a database,
 - We want it to work as a spreadsheet.

People are going to start with the spreadsheet.
Hmm, let's just optimise for the spreadsheet case first, yeah?

A couple of ways of looking at it:
  - AirTable is super structured. Quite restrictive. What do they get out of it?
    - Foreign key constraints,
    - Simple "order of execution",
    - More scriptability because the formulas generalise.
  - Excel is very loose. What do they get out of it?
    - More use-cases covered,
    - More user-exploration and rapid-prototyping possible.

Things they are used for:
 - Records,
 - Series data with calculations,
   - Pure series calculations after t=0,
 - Matrices
 - Drawing pictures :-/

Time-series tends to go left-to-right? Hmm. Well, whatever, new habits.
  - Bad attitude.

We could make it easy to copy, and maybe fix up references if the users wants to "copy, transform and hide the old one"?
  - Like a what-if...
    `=restOfTheData(table1=table1(col1 = table1.col1 + 1))`

I like the idea of taking a table and adding rows to the bottom and columns to the right. Has to be user-friendly, though.
  Colour-coding based on insertion order? Re-ordering possible?
  To the user it can look like "horizontal borders between rows when the formulas change." I think that's a useful heuristic.

Maybe there are three kinds of rows:
 - Add a row,
 - Maybe add a row,
 - Repeatedly add rows.
